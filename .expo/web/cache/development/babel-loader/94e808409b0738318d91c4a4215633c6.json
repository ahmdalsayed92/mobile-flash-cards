{"ast":null,"code":"function _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\nfunction _toPropertyKey(arg) { var key = _toPrimitive(arg, \"string\"); return typeof key === \"symbol\" ? key : String(key); }\n\nfunction _toPrimitive(input, hint) { if (typeof input !== \"object\" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || \"default\"); if (typeof res !== \"object\") return res; throw new TypeError(\"@@toPrimitive must return a primitive value.\"); } return (hint === \"string\" ? String : Number)(input); }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? Object(arguments[i]) : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { GET_ALL_DECKS, ADD_NEW_DECK, REMOVE_CERTAIN_DECK, ADD_NEW_CARD, RESET_DATA } from \"../actions/index\";\nimport { decks as INITIAL_STATE } from \"../utils/_DATA\";\nexport default function decks() {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case GET_ALL_DECKS:\n      return _objectSpread({}, state, action.decks);\n\n    case ADD_NEW_DECK:\n      const {\n        title\n      } = action;\n      return _objectSpread({}, state, {\n        [title]: {\n          title,\n          questions: []\n        }\n      });\n\n    case REMOVE_CERTAIN_DECK:\n      const {\n        id\n      } = action;\n\n      const {\n        [id]: value\n      } = state,\n            remainingDecks = _objectWithoutProperties(state, [id].map(_toPropertyKey));\n\n      return remainingDecks;\n\n    case ADD_NEW_CARD:\n      const {\n        deckId,\n        card\n      } = action;\n      return _objectSpread({}, state, {\n        [deckId]: _objectSpread({}, state[deckId], {\n          questions: [...state[deckId].questions].concat(card)\n        })\n      });\n\n    case RESET_DATA:\n      return INITIAL_STATE;\n\n    default:\n      return state;\n  }\n}","map":{"version":3,"sources":["/Users/ahmedelsayed/work/learn/nanoDegree/flash cards/untitled folder/Mobile-flash-card-master/reducers/index.js"],"names":["GET_ALL_DECKS","ADD_NEW_DECK","REMOVE_CERTAIN_DECK","ADD_NEW_CARD","RESET_DATA","decks","INITIAL_STATE","state","action","type","title","questions","id","value","remainingDecks","deckId","card","concat"],"mappings":";;;;;;;;;;;;AAAA,SAASA,aAAT,EAAwBC,YAAxB,EAAsCC,mBAAtC,EAA2DC,YAA3D,EAAyEC,UAAzE;AACA,SAASC,KAAK,IAAIC,aAAlB;AAEA,eAAe,SAASD,KAAT,GAAmC;AAAA,MAApBE,KAAoB,uEAAZ,EAAY;AAAA,MAARC,MAAQ;;AAChD,UAAQA,MAAM,CAACC,IAAf;AACE,SAAKT,aAAL;AACE,+BACKO,KADL,EAEKC,MAAM,CAACH,KAFZ;;AAIF,SAAKJ,YAAL;AACE,YAAM;AAAES,QAAAA;AAAF,UAAYF,MAAlB;AACA,+BACKD,KADL;AAEE,SAACG,KAAD,GAAS;AACPA,UAAAA,KADO;AAEPC,UAAAA,SAAS,EAAE;AAFJ;AAFX;;AAOF,SAAKT,mBAAL;AACE,YAAM;AAAEU,QAAAA;AAAF,UAASJ,MAAf;;AAEA,YAAM;AAAE,SAACI,EAAD,GAAMC;AAAR,UAAqCN,KAA3C;AAAA,YAAwBO,cAAxB,4BAA2CP,KAA3C,GAASK,EAAT;;AAEA,aAAOE,cAAP;;AACF,SAAKX,YAAL;AACE,YAAM;AAAEY,QAAAA,MAAF;AAAUC,QAAAA;AAAV,UAAmBR,MAAzB;AACA,+BACKD,KADL;AAEE,SAACQ,MAAD,qBACKR,KAAK,CAACQ,MAAD,CADV;AAEEJ,UAAAA,SAAS,EAAE,CAAC,GAAGJ,KAAK,CAACQ,MAAD,CAAL,CAAcJ,SAAlB,EAA6BM,MAA7B,CAAoCD,IAApC;AAFb;AAFF;;AAOF,SAAKZ,UAAL;AACE,aAAOE,aAAP;;AACF;AACE,aAAOC,KAAP;AAjCJ;AAmCD","sourcesContent":["import { GET_ALL_DECKS, ADD_NEW_DECK, REMOVE_CERTAIN_DECK, ADD_NEW_CARD, RESET_DATA } from '../actions/index';\r\nimport { decks as INITIAL_STATE } from '../utils/_DATA';\r\n\r\nexport default function decks(state = {}, action) {\r\n  switch (action.type) {\r\n    case GET_ALL_DECKS:\r\n      return {\r\n        ...state,\r\n        ...action.decks\r\n      };\r\n    case ADD_NEW_DECK:\r\n      const { title } = action;\r\n      return {\r\n        ...state,\r\n        [title]: {\r\n          title,\r\n          questions: []\r\n        }\r\n      };\r\n    case REMOVE_CERTAIN_DECK:\r\n      const { id } = action;\r\n      // return ({ [id]: value, ...remainingDecks } = state);\r\n      const { [id]: value, ...remainingDecks } = state;\r\n      // console.log(remainingDecks);\r\n      return remainingDecks;\r\n    case ADD_NEW_CARD:\r\n      const { deckId, card } = action;\r\n      return {\r\n        ...state,\r\n        [deckId]: {\r\n          ...state[deckId],\r\n          questions: [...state[deckId].questions].concat(card)\r\n        }\r\n      };\r\n    case RESET_DATA:\r\n      return INITIAL_STATE;\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}